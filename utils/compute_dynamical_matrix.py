import os
import numpy as np
from ase.io import read

def calculate_dynamical_matrix(atoms, d=0.01):
    """
    Calculates the dynamical matrix from Quantum ESPRESSO output files
    generated by the finite difference method.

    Args:
        atoms: ASE atoms object
        d (float, optional): The displacement in Angstroms.  Must match the
            displacement used in the input file generation. Defaults to 0.01.

    Returns:
        numpy.ndarray: The dynamical matrix (3N x 3N), or None on error.
    """

    # Get number of atoms and initialize the dynamical matrix
    N = len(atoms)
    dynamical_matrix = np.zeros((3 * N, 3 * N))
    # Get the atomic masses.  ASE stores them in atomic mass units (amu).
    masses = atoms.get_masses()

    # Loop over each atom and direction
    for i in range(N):
        for j in range(3):
            # Construct file names.
            filename_plus  = f"atom_{i+1}_dir_{j+1}_1.out"
            filename_minus = f"atom_{i+1}_dir_{j+1}_-1.out"

            # Read forces from the output files.
            forces_plus = read(filename_plus, format='espresso-out').get_forces()
            forces_minus = read(filename_minus, format='espresso-out').get_forces()

            # Calculate the derivative of the forces.
            dF = (forces_plus - forces_minus) / (2 * d)  # Central difference

            # Fill in the dynamical matrix.
            for k in range(N):
                for l in range(3):
                    dynamical_matrix[3 * k + l, 3 * i + j] = -1*dF[k, l] / np.sqrt(masses[i]*masses[k])

    return dynamical_matrix

def print_dynamical_matrix(dynamical_matrix, atoms):
    """
    Prints the dynamical matrix in a readable format.

    Args:
        dynamical_matrix (numpy.ndarray): The dynamical matrix (3N x 3N).
        atoms (ase.Atoms): The Atoms object, used for getting the symbols.
    """

    N = len(atoms)
    print("Dynamical Matrix (eV/Angstrom^2/amu):")
    for i in range(3 * N):
        for j in range(3 * N):
            print(f"{dynamical_matrix[i, j]:12.6f}", end=" ")
        print()  # Newline after each row

    # Print the elements in a more readable format, grouped by atom and direction:
    print("\nDynamical Matrix (Atom and Direction):")
    atom_symbols = atoms.get_chemical_symbols()
    for i in range(N):
        for j in range(3):
            for k in range(N):
                for l in range(3):
                    print(
                        f"Atom {i+1} ({atom_symbols[i]}) Dir {j+1} -> Atom {k+1} ({atom_symbols[k]}) Dir {l+1}:  {dynamical_matrix[3*k+l, 3*i+j]:12.6f} eV/Angstrom^2"
                    )

def calculate_and_print_eigenvalues(dynamical_matrix):
    """
    Calculates the eigenvalues of the dynamical matrix and prints them.

    Args:
        dynamical_matrix (numpy.ndarray): The dynamical matrix (3N x 3N).
    """

    # Calculate the eigenvalues.  Use np.linalg.eig
    eigenvalues = np.linalg.eig(dynamical_matrix)[0] # [0] gets the eigenvalues, [1] is eigenvectors

    # Convert eigenvalues to cm^-2
    # The dynamical matrix is in  eV/Angstrom^2 / amu
    # 1 eV = 1.602176634e-19 J
    # 1 Angstrom = 1e-10 m
    # 1 amu = 1.66053906660e-27 kg
    # 1 J = 1 kg * m^2 / s^2
    # speed of light c = 299792458 m/s  = 2.99792458e10 cm/s
    # conversion factor  = (1.602176634e-19 J/eV) / (1e-10 m/Angstrom)^2 / (1.66053906660e-27 kg/amu) / (c^2 cm^2/s^2)
    conversion_factor = 1.602176634e-19 / (1e-10)**2 / 1.66053906660e-27 / (29979245800)**2
    eigenvalues_in_cm2 = eigenvalues * conversion_factor / (4*np.pi**2)

    print("\nEigenvalues of the Dynamical Matrix (cm^-2), Vibrational frequencies (cm^-1):")
    for i, eigenvalue in enumerate(eigenvalues_in_cm2):
        if eigenvalue>0:
            print(f"Eigenvalue, frequency {i+1}: {eigenvalue:12.6f}, {np.sqrt(eigenvalue):12.6f}")
        else:
            print(f"Eigenvalue {i+1}: {eigenvalue:12.6f}")

if __name__ == "__main__":

    # 1. Read one output file to extract number of atoms and masses 
    atoms = read("atom_1_dir_1_1.out")

    # 2. Calculate the dynamical matrix.
    dynamical_matrix = calculate_dynamical_matrix(atoms, d=0.01)

    if dynamical_matrix is not None:

        # 3. Print the dynamical matrix.
        print_dynamical_matrix(dynamical_matrix, atoms)

        # 4. Print the normal modes
        calculate_and_print_eigenvalues(dynamical_matrix)

