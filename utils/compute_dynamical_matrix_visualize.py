import os
import numpy as np
from ase.io import read
from vpython import * # Import VPython for visualization

def calculate_dynamical_matrix(atoms, d=0.01):
    """
    Calculates the dynamical matrix from Quantum ESPRESSO output files
    generated by the finite difference method.

    Args:
        atoms: ASE atoms object
        d (float, optional): The displacement in Angstroms.  Must match the
            displacement used in the input file generation. Defaults to 0.01.

    Returns:
        numpy.ndarray: The dynamical matrix (3N x 3N), or None on error.
    """

    # Get number of atoms and initialize the dynamical matrix
    N = len(atoms)
    dynamical_matrix = np.zeros((3 * N, 3 * N))
    # Get the atomic masses.  ASE stores them in atomic mass units (amu).
    masses = atoms.get_masses()

    # Loop over each atom and direction
    for i in range(N):
        for j in range(3):
            # Construct file names.
            filename_plus  = f"atom_{i+1}_dir_{j+1}_1.out"
            filename_minus = f"atom_{i+1}_dir_{j+1}_-1.out"

            # Read forces from the output files.
            forces_plus = read(filename_plus, format='espresso-out').get_forces()
            forces_minus = read(filename_minus, format='espresso-out').get_forces()

            # Calculate the derivative of the forces.
            dF = (forces_plus - forces_minus) / (2 * d)  # Central difference

            # Fill in the dynamical matrix.
            for k in range(N):
                for l in range(3):
                    dynamical_matrix[3 * k + l, 3 * i + j] = -1*dF[k, l] / np.sqrt(masses[i]*masses[k])

    return dynamical_matrix

def print_dynamical_matrix(dynamical_matrix, atoms):
    """
    Prints the dynamical matrix in a readable format.

    Args:
        dynamical_matrix (numpy.ndarray): The dynamical matrix (3N x 3N).
        atoms (ase.Atoms): The Atoms object, used for getting the symbols.
    """

    N = len(atoms)
    print("Dynamical Matrix (eV/Angstrom^2/amu):")
    for i in range(3 * N):
        for j in range(3 * N):
            print(f"{dynamical_matrix[i, j]:12.6f}", end=" ")
        print()  # Newline after each row

    # Print the elements in a more readable format, grouped by atom and direction:
    print("\nDynamical Matrix (Atom and Direction):")
    atom_symbols = atoms.get_chemical_symbols()
    for i in range(N):
        for j in range(3):
            for k in range(N):
                for l in range(3):
                    print(
                        f"Atom {i+1} ({atom_symbols[i]}) Dir {j+1} -> Atom {k+1} ({atom_symbols[k]}) Dir {l+1}:  {dynamical_matrix[3*k+l, 3*i+j]:12.6f} eV/Angstrom^2"
                    )

def calculate_and_print_eigenvalues(dynamical_matrix):
    """
    Calculates the eigenvalues of the dynamical matrix and prints them.

    Args:
        dynamical_matrix (numpy.ndarray): The dynamical matrix (3N x 3N).
    """

    # Calculate the eigenvalues.  Use np.linalg.eig
    eigenvalues, eigenvectors = np.linalg.eig(dynamical_matrix) # [0] gets the eigenvalues, [1] is eigenvectors

    # Convert eigenvalues to cm^-2
    # The dynamical matrix is in  eV/Angstrom^2 / amu
    # 1 eV = 1.602176634e-19 J
    # 1 Angstrom = 1e-10 m
    # 1 amu = 1.66053906660e-27 kg
    # 1 J = 1 kg * m^2 / s^2
    # speed of light c = 299792458 m/s  = 2.99792458e10 cm/s
    # conversion factor  = (1.602176634e-19 J/eV) / (1e-10 m/Angstrom)^2 / (1.66053906660e-27 kg/amu) / (c^2 cm^2/s^2)
    conversion_factor = 1.602176634e-19 / (1e-10)**2 / 1.66053906660e-27 / (29979245800)**2
    eigenvalues_in_cm2 = eigenvalues * conversion_factor / (4*np.pi**2)

    print("\nEigenvalues of the Dynamical Matrix (cm^-2), Vibrational frequencies (cm^-1):")
    for i, eigenvalue in enumerate(eigenvalues_in_cm2):
        if eigenvalue>0:
            print(f"Eigenvalue, frequency {i+1}: {eigenvalue:12.6f}, {np.sqrt(eigenvalue):12.6f}")
        else:
            print(f"Eigenvalue {i+1}: {eigenvalue:12.6f}")

    return eigenvalues_in_cm2, eigenvectors

def visualize_normal_modes(atoms, eigenvectors, eigenvalues_in_cm2, scale=0.1, animation_time=10):
    """
    Visualizes the normal modes of vibration using VPython with animation.

    Args:
        atoms (ase.Atoms): The Atoms object.
        eigenvectors (numpy.ndarray): The eigenvectors of the dynamical matrix.
        eigenvalues_in_cm2 (numpy.ndarray): The eigenvalues of the dynamical matrix (in cm^-2).
        scale (float, optional): Scaling factor for the displacement vectors.
        animation_time (float, optional):  The total time in seconds for the animation.
    """
    N = len(atoms)
    positions = atoms.get_positions()
    symbols = atoms.get_chemical_symbols()

    # Create VPython scene
    scene = canvas(title='Normal Modes of Vibration', background=color.white)

    # Create spheres for atoms
    atom_spheres = []
    for i in range(N):
        atom_color = {'C': color.black, 'H': color.white, 'O': color.red,
                      'N': color.blue}.get(symbols[i], color.gray)  # Added more colors
        atom_sphere = sphere(pos=vector(positions[i, 0], positions[i, 1],
                                        positions[i, 2]),
                            radius=0.3, color=atom_color)
        atom_spheres.append(atom_sphere)

    # Visualize each normal mode
    for mode_index in range(3 * N):
        # Clear previous arrows
        for obj in scene.objects:
            if isinstance(obj, arrow):
                obj.visible = False

        # Get the eigenvector for the current mode
        eigenvector = eigenvectors[:, mode_index]
        # Reshape the eigenvector to get the displacement vectors for each atom
        displacements = eigenvector.reshape((N, 3))

        # Create arrows for displacements
        arrows = []
        for i in range(N):
            arrow_obj = arrow(pos=atom_spheres[i].pos,
                            axis=vector(displacements[i, 0], displacements[i, 1],
                                        displacements[i, 2]) * scale * 20,
                            color=color.green)
            arrows.append(arrow_obj)

        # Display mode information
        title_text = text(
            text=f'Mode {mode_index + 1}, Frequency: {np.sqrt(np.abs(eigenvalues_in_cm2[mode_index])):.2f} cm^-1',
            pos=vector(-5, 5, 0), color=color.black, billboard=True, height=0.4)  # Use billboard=True

        # Animation loop
        t = 0
        dt = 0.1  # Time step
        rate_factor = 10 # Controls the speed of the animation
        while t < animation_time:
            rate(rate_factor)  # Control the speed of the animation
            for i in range(N):
                # Calculate the displaced position of each atom
                new_pos = positions[i] + displacements[i] * scale * np.sin(t * np.sqrt(np.abs(eigenvalues_in_cm2[mode_index])))
                atom_spheres[i].pos = vector(new_pos[0], new_pos[1], new_pos[2])
            t += dt

        # Remove the arrows and text
        for arrow_obj in arrows:
            arrow_obj.visible = False
        title_text.visible = False

if __name__ == "__main__":

    # 1. Read one output file to extract number of atoms and masses 
    atoms = read("atom_1_dir_1_1.out")

    # 2. Calculate the dynamical matrix.
    dynamical_matrix = calculate_dynamical_matrix(atoms, d=0.01)

    if dynamical_matrix is not None:

        # 3. Print the dynamical matrix.
        print_dynamical_matrix(dynamical_matrix, atoms)

        # 4. Print the normal modes
        eigenvalues, eigenvectors = calculate_and_print_eigenvalues(dynamical_matrix)

        # 5. Visualize the normal modes
        visualize_normal_modes(atoms, eigenvectors, eigenvalues, scale=0.1)

